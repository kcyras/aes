\chapter{Implementation}

\section{Design Decisions}

To select a programming language suitable for developing the tool, languages were compared with respect to possible challenges. The language should be compatible with popular optimisation solvers. To make efficient use of time, using an existing interface library between popular solvers is recommended. Interfaces are written for popular languages such as C++, Java and Python. Python was selected for its development speed and support for a wide range of libraries.
\linespace
There is a balance between program speed and development time. A tool written in C may be fast but time-consuming. The purpose is to demonstrate the concept of argumentation with schedules while allowing analysis of potential future directions and short-comings. Hence, the tool should be sufficiently fast to be responsive, but not necessarily fast as possible.
\linespace
There are many powerful and efficient solvers such as CPLEX [paper] and GLPK [paper]. To solver large problems, users use commercial over open-source solvers for their superior speed [paper]. However, users may not have access to a commercial solver. To accommodate users, Pyomo is used to interface to many popular solvers.
\linespace
The tool features a GUI to aid its accessibility. Users such as hospital managers can often use a suitably-designed GUI without training of the tool. In practice, a GUI is easier to demonstrate than a CLI.

\section{Structure}

\begin{tikzpicture}
	\fill[fill=black!10](-1.7, -0.8) rectangle (11.2, 3);
	\node at (0, 0){External libraries};

	\node[file](cplex) at (6, 0){CPLEX};
	\node[file](glpk) at (10, 0){GLPK};
	\node[file](graphviz) at (0, 2){Graphviz};
	\node[file](tkinter) at (4, 2){Tkinter};		
	\node[file](pyomo) at (8, 2){Pyomo};
	\node[file](visualise) at (0, 4){\verb|visualise.py|};
	\node[file](graphical) at (4, 4){\verb|graphical.py|};
	\node[file](solver) at (8, 4){\verb|solver.py|};
	\node[file](schedule) at (0, 6){\verb|schedule.py|};
	\node[file](argumentation) at (0, 8){\verb|argumentation.py|};
	\node[file](interface) at (4, 8){\verb|interface.py|};
	\node[file](main) at (4, 10){\verb|main.py|};
	\draw[arrow, dashed](cplex) -- (pyomo);
	\draw[arrow, dashed](glpk) -- (pyomo);
	\draw[arrow](graphviz) -- (visualise);
	\draw[arrow](pyomo) -- (solver);
	\draw[arrow](tkinter) -- (graphical);
	\draw[arrow](visualise) -- (graphical);
	\draw[arrow](graphical) -- (interface);
	\draw[arrow](solver) -- (interface);
	\draw[arrow](argumentation) -- (interface);
	\draw[arrow](schedule) -- (interface);
	\draw[arrow](schedule) -- (argumentation);
	\draw[arrow](interface) -- (main);
\end{tikzpicture}

The above graph illustrates the functional dependency between modules. A solver is required for full functionality of the tool. This could be CPLEX or GLPK.

\section{Algorithms}

\subsection{Notation}

\begin{definition}
	Let $\mathbf{0}^{d_1, ..., d_n}$ be the zero-valued binary tensor. The dimensions may be omitted if clear. Matrix subscripts are extended to $n$ dimensions.
		
	For example:
	\begin{align*}
	\mathbf{0}^{2\times 2}&=
	\begin{bmatrix}
	0&0\\
	0&0\\
	\end{bmatrix}
	\end{align*}
\end{definition}

\begin{definition}
	Let $\incircbin{\neg}$ be the element-wise logical negation operator over a tensor.
	
	For example:
	\begin{align*}
		\incircbin{\neg}
		\begin{bmatrix}
		1&0\\
		0&1\\
		\end{bmatrix}&=
		\begin{bmatrix}
			0&1\\
			1&0\\
		\end{bmatrix}
	\end{align*}
\end{definition}

\begin{definition}
	Let $\incircbin{\land}$ be the element-wise logical and operator over tensors.
	
	For example:
	\begin{align*}
	\begin{bmatrix}
	0&0\\
	1&1\\
	\end{bmatrix}
	\incircbin{\land}
	\begin{bmatrix}
	0&1\\
	0&1\\
	\end{bmatrix}
	&=
	\begin{bmatrix}
	0&0\\
	0&1\\
	\end{bmatrix}
	\end{align*}
\end{definition}

\begin{definition}
	Let $\incircbin{\lor}$ be the element-wise logical or operator over tensors.
	
	For example:
	\begin{align*}
	\begin{bmatrix}
	0&0\\
	1&1\\
	\end{bmatrix}
	\incircbin{\lor}
	\begin{bmatrix}
	0&1\\
	0&1\\
	\end{bmatrix}
	&=
	\begin{bmatrix}
	0&1\\
	1&1\\
	\end{bmatrix}
	\end{align*}
\end{definition}

\subsection{Framework Construction}

The AAFs are constructed using the definitions in paper.\cite{aes} The definitions are reprinted below. Take arbitrary $i_1,i_2\in\mathcal{M}$ and $j_1,j_2\in\mathcal{J}$.

\begin{definition}
	The feasiblity framework $\rightsquigarrow_F$ is defined such that $\langle i_1,j_1\rangle\rightsquigarrow_F\langle i_2,j_2\rangle$ iff $i_1\neq i_2\land j_1=j_2$.
\end{definition}

\begin{definition}
	The efficiency framework $\rightsquigarrow_S$ is defined such that $\langle i_1,j_1\rangle\rightsquigarrow_S\langle i_2,j_2\rangle\land\neg\text{SEP}(i_1,i_2,j_1)\lor\text{PEP}(i_1,i_2,j_1,j_2)$ where:
	\begin{itemize}
		\item Single exchange property: $\text{SEP}(i_1,i_2,j_1)$ iff $C_{i_1}=C_{\max}\land x_{i_1,j_1}=1\land C_{i_1}>C_{i_2}+p_{j_1}$
		\item Pair-wise exchange property: $\text{PEP}(i_1,i_2,j_1,j_2)$ iff $C_{i_1}=C_{\max}\land x_{i_1,j_1}=1\land x_{i_2,j_2}=1\land i_1\neq i_2\land j_1\neq j_2\land p_{j_1}>p_{j_2}\land C_{i_1}+p_{j_2}>C_{i_2}+p_{j_1}$.
	\end{itemize}
\end{definition}

\begin{definition}
	The fixed user decision framework $\rightsquigarrow_D$ is defined such that $\langle i_1,j_1\rangle\rightsquigarrow_S\langle i_2,j_2\rangle\land\neg\text{DP}^+(i_1,i_2,j_1,j_2)\lor\text{DP}^-(i_1,i_2,j_1,j_2)$ where:
	\begin{itemize}
		\item Positive decision property: $\text{DP}^+(i_1,i_2,j_1,j_2)$ iff $\langle i_2, j_2\rangle\in D^+$
		\item Negative decision property: $\text{DP}^-(i_1,i_2,j_1,j_2)$ iff $\langle i_1, j_1\rangle\in D^-\land i_1=i_2\land j_1=j_2$.
	\end{itemize}
\end{definition}

\begin{algorithm}[h!]
	\begin{algorithmic}[1]
		\Function{Construct-Feasibilty}{$m$, $n$}
			\State $\rightsquigarrow_F$ $\gets$ $\mathbf{0}^{(m\times n)^2}$
			\For{$j\in\mathcal{J}$}
				\For{$i_1\in\mathcal{M}$}
					\For{$i_2\in\mathcal{M}$}
						\If{$i_1\neq i_2$}
							\State ${\rightsquigarrow_F}_{i_1,j,i_2,j}$ $\gets$ 1
						\EndIf
					\EndFor
				\EndFor
			\EndFor
			\State \Return $\rightsquigarrow_F$
		\EndFunction
	\end{algorithmic}
\end{algorithm}

$\rightsquigarrow_F$ can be constructed trivially in a dense data structure in $\mathcal{O}(m^2n^2)$ computational complexity. because of the complexity of zero-initialising $\rightsquigarrow_F$. This can be constructed in $\mathcal{O}(m^2n)$ complexity using a sparse data structure, but results in greatly more complicated code.

\begin{algorithm}[h!]
	\begin{algorithmic}[1]
		\Function{Construct-Efficiency}{$m$, $n$, $\mathbf{p}$, $\mathbf{x}$, $\rightsquigarrow_F$}
			\State $\mathbf{C}$ $\gets$ $\mathbf{x}\cdot\mathbf{p}$
			\State $C_{\max}$ $\gets$ $\max(\mathbf{C})$
			\State $\rightsquigarrow_S$ $\gets$ $\rightsquigarrow_F$
			\For{$i_1\in\mathcal{M}$}
				\If{$i_1\neq C_{\max}$}
					\For{$j_1\in\mathcal{J}$}
						\If{$x_{i_1,j_1}=1$}
							\For{$i_2\in\mathcal{M}$}
								\If{$\text{SEP}(i_1,j_1,i_2)$}
									\State ${\rightsquigarrow_S}_{i_1,j_1,i_2,j_1}$ $\gets$ 0
								\EndIf
								\For{$j_2\in\mathcal{J}$}
									\If{$\text{PEP}(i_1,j_1,i_2,j_2)$}
										\State ${\rightsquigarrow_S}_{i_1,j_2,i_2,j_2}$ $\gets$ 1
									\EndIf
								\EndFor
							\EndFor
						\EndIf
					\EndFor
				\EndIf
			\EndFor
			\State \Return $\rightsquigarrow_S$
		\EndFunction
	\end{algorithmic}
\end{algorithm}

The construction of $\rightsquigarrow_S$ is expensive because of the explicit for-loops to iterate over the $\mathcal{M}^2\mathcal{J}^2$ space to compute the edges that satisfy PEP and to copy $\rightsquigarrow_F$. An optimisation by computing SEP outside of the $j_2$ loop, because PEP is invariant of $j_2$.

\begin{algorithm}[h!]
	\begin{algorithmic}[1]
		\Function{Construct-Efficiency}{$m$, $n$, $D$, $\rightsquigarrow_F$}
			\State $\rightsquigarrow_D$ $\gets$ $\rightsquigarrow_F$
			\For{$\langle i,j\rangle\in D^-$}
				\State ${\rightsquigarrow_S}_{i,j,i,j}$ $\gets$ 1
			\EndFor
			\For{$\langle i_1,j_1\rangle\in D^+$}
				\For{$i_2\in\mathcal{M}$}
					\For{$j_2\in\mathcal{J}$}
						\State ${\rightsquigarrow_D}_{i_2,j_2,i_1,j_1}$ $\gets$ 0				
					\EndFor
				\EndFor
			\EndFor
			\State \Return $\rightsquigarrow_D$
		\EndFunction
	\end{algorithmic}
\end{algorithm}

The construction of $\rightsquigarrow_D$ has $\mathcal{O}(m^2n^2)$ computational complexity. If $D$ is assumed to be satisfiable, then $D^+$ has at most $n$ decisions while $D^-$ has at most $m-1)n$ decisions. However, if $D$ is not necessarily satisfiable to account for poorly-formulated user problems, so in general $D^+$ and $D^-$ has at most $mn$ decisions.

\subsection{Stability}

Stability can be computed by checking whether $E$ exists within a all possible stable extensions of some $\langle Args, \rightsquigarrow\rangle$. However, a schedule cannot be reasoned on without understanding whether $E$ may be stable on $\langle Args, \rightsquigarrow\rangle$. Existing solutions require a complication pipeline using answer set solvers. To make the implementation of the tool easier, we adapt the stability computation to schedules into a concise algorithm.

\begin{algorithm}[h!]
	\begin{algorithmic}[1]
		\Function{Explain-Stability}{$\mathbf{x}$, $\rightsquigarrow$,
			 ignoreUnattacked, ignoreConflicts}
			\State unattacked $\gets\incircbin{\neg}$ $\mathbf{x}$
			\State conflicts $\gets\mathbf{0}^{(m\times n)^2}$
			\For{$i\in\mathcal{M}$}
				\For{$j\in\mathcal{J}$}
					\If{$E_{i,j}=1$}
						\State unattacked $\gets$ unattacked $\incircbin{\land}$ $\incircbin{\neg}\rightsquigarrow_{i,j}$
						\State conflicts$_{i,j}$ $\gets$ $\mathbf{x}$ $\incircbin{\land}$ $\rightsquigarrow_{i,j}$ 
					\EndIf
				\EndFor
			\EndFor
			\State unattacked $\gets$ unattacked $\incircbin{\land}$ $\incircbin{\neg}$ ignoreUnattacked
			\State conflicts $\gets$ conflicts $\incircbin{\land}$ $\incircbin{\neg}$ ignoreConflicts
			\State \Return unattacked, conflicts
		\EndFunction
	\end{algorithmic}
\end{algorithm}

The function returns two tensors, \emph{unattacked} encode the unattacked nodes and \emph{conflicts} encode the edges are not conflict-free. \emph{ignoreUnattack} and \emph{ignoreConflicts} represent node and edges to ignore from returned values respectively, which are useful in tailoring explanations to particular constraints. By default, ignoreUnattacked $=\mathbf{0}$ and ignoreConflicts $=\mathbf{0}$. The algorithm has $\mathcal{O}(m^2n^2)$ computational and memory complexity. The function uses $\mathbf{x}$ rather than its equivalent representation $E$ because $\mathbf{x}$ can be manipulated directly from an optimiser in its tensor form unlike $E$. In addition, it is assumed that $E\subseteq Args$ so $Args$ does not need to be a parameter.

\begin{theorem}
	\textsc{Explain-Stability} is correct where $\mathbf{x}\approx E$ under $S$:
	\begin{align*}
		\textsc{Explain-Stability}(\mathbf{x},\rightsquigarrow,\mathbf{0},\mathbf{0})=\langle \mathbf{0},\mathbf{0}\rangle\Leftrightarrow E\text{ is stable on }\langle Args, \rightsquigarrow\rangle
	\end{align*}
\end{theorem}
	
\subsection{Explanation}

\begin{algorithm}[h!]
	\begin{algorithmic}[1]
		\Function{Explain-Schedule}{$m$, $n$, $\mathbf{p}$, $D$, $\mathbf{x}$}
				\State $\rightsquigarrow_F$ $\gets$ \textsc{Construct-Feasibility}($m$, $n$)
				\State $\langle$ unattacked\textsubscript{F}, conflicts\textsubscript{F} $\rangle$ $\gets$ \textsc{Explain-Stability}($\mathbf{x}$, $\rightsquigarrow_F$, $\mathbf{0}$, $\mathbf{0}$)
				\State\textsc{Explain-Feasibility}(unattacked\textsubscript{F}, conflicts\textsubscript{F})

				\State $\rightsquigarrow_S$ $\gets$ \textsc{Construct-Efficiency}($m$, $n$, $\mathbf{p}$, $\mathbf{x}$, $\rightsquigarrow_F$)
				\State $\langle$ unattacked\textsubscript{S}, conflicts\textsubscript{S} $\rangle$ $\gets$ \textsc{Explain-Stability}($\mathbf{x}$, $\rightsquigarrow_S$, unattacked\textsubscript{F}, conflicts\textsubscript{F})
				\State\textsc{Explain-Efficiency}(unattacked\textsubscript{S}, conflicts\textsubscript{S})

				\State $\rightsquigarrow_D$ $\gets$ \textsc{Construct-Satisfaction}($m$, $n$, $\mathbf{x}$, $\rightsquigarrow_F$)
				\State $\langle$ unattacked\textsubscript{D}, conflicts\textsubscript{D} $\rangle$ $\gets$ \textsc{Explain-Stability}($\mathbf{x}$, $\rightsquigarrow_D$, unattacked\textsubscript{F}, conflicts\textsubscript{F})
				\State\textsc{Explain-Satisfaction}(unattacked\textsubscript{D}, conflicts\textsubscript{D})
		\EndFunction
	\end{algorithmic}
\end{algorithm}
