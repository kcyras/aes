\chapter{Implementation}

\section{Design Decisions}

To select a programming language suitable for developing the tool, languages were compared with respect to possible challenges. The language should be compatible with popular optimisation solvers. To make efficient use of time, using an existing interface library between popular solvers is recommended. Interfaces are written for popular languages such as C++, Java and Python. Python was selected for its development speed and support for a wide range of libraries.
\linespace
There is a balance between program speed and development time. A tool written in C may be fast but time-consuming. The purpose is to demonstrate the concept of argumentation with schedules while allowing analysis of potential future directions and short-comings. Hence, the tool should be sufficiently fast to be responsive, but not necessarily fast as possible.
\linespace
There are many powerful and efficient solvers such as CPLEX [paper] and GLPK [paper]. To solver large problems, users use commercial over open-source solvers for their superior speed [paper]. However, users may not have access to a commercial solver. To accommodate users, Pyomo is used to interface to many popular solvers.
\linespace
The tool features a GUI to aid its accessibility. Users such as hospital managers can often use a suitably-designed GUI without training of the tool. In practice, a GUI is easier to demonstrate than a CLI.

\section{Structure}

\begin{tikzpicture}
	\fill[fill=black!10](-1.7, -0.8) rectangle (11.2, 3);
	\node at (0, 0){External libraries};

	\node[file](cplex) at (6, 0){CPLEX};
	\node[file](glpk) at (10, 0){GLPK};
	\node[file](graphviz) at (0, 2){Graphviz};
	\node[file](tkinter) at (4, 2){Tkinter};		
	\node[file](pyomo) at (8, 2){Pyomo};
	\node[file](visualise) at (0, 4){\verb|visualise.py|};
	\node[file](graphical) at (4, 4){\verb|graphical.py|};
	\node[file](solver) at (8, 4){\verb|solver.py|};
	\node[file](schedule) at (0, 6){\verb|schedule.py|};
	\node[file](argumentation) at (0, 8){\verb|argumentation.py|};
	\node[file](interface) at (4, 8){\verb|interface.py|};
	\node[file](main) at (4, 10){\verb|main.py|};
	\draw[arrow, dashed](cplex) -- (pyomo);
	\draw[arrow, dashed](glpk) -- (pyomo);
	\draw[arrow](graphviz) -- (visualise);
	\draw[arrow](pyomo) -- (solver);
	\draw[arrow](tkinter) -- (graphical);
	\draw[arrow](visualise) -- (graphical);
	\draw[arrow](graphical) -- (interface);
	\draw[arrow](solver) -- (interface);
	\draw[arrow](argumentation) -- (interface);
	\draw[arrow](schedule) -- (interface);
	\draw[arrow](schedule) -- (argumentation);
	\draw[arrow](interface) -- (main);
\end{tikzpicture}

The above graph illustrates the functional dependency between modules. A solver is required for full functionality of the tool. This could be CPLEX or GLPK.

\section{Algorithms}

\subsection{Notation}

\begin{definition}
	Let $\mathbf{0}^{d_1, ..., d_n}$ be the zero-valued binary tensor. The dimensions may be omitted if clear. Matrix subscripts are extended to $n$ dimensions.
		
	For example:
	\begin{align*}
	\mathbf{0}^{2\times 2}&=
	\begin{bmatrix}
	0&0\\
	0&0\\
	\end{bmatrix}
	\end{align*}
\end{definition}

\begin{definition}
	Let $\incircbin{\neg}$ be the element-wise logical negation operator over a tensor.
	
	For example:
	\begin{align*}
		\incircbin{\neg}
		\begin{bmatrix}
		1&0\\
		0&1\\
		\end{bmatrix}&=
		\begin{bmatrix}
			0&1\\
			1&0\\
		\end{bmatrix}
	\end{align*}
\end{definition}

\begin{definition}
	Let $\incircbin{\land}$ be the element-wise logical and operator over a tensor.
	
	For example:
	\begin{align*}
	\begin{bmatrix}
	0&0\\
	1&1\\
	\end{bmatrix}
	\incircbin{\land}
	\begin{bmatrix}
	0&1\\
	0&1\\
	\end{bmatrix}
	&=
	\begin{bmatrix}
	0&0\\
	0&1\\
	\end{bmatrix}
	\end{align*}
\end{definition}

\begin{definition}
	Let $\incircbin{\lor}$ be the element-wise logical or operator over a tensor.
	
	For example:
	\begin{align*}
	\begin{bmatrix}
	0&0\\
	1&1\\
	\end{bmatrix}
	\incircbin{\lor}
	\begin{bmatrix}
	0&1\\
	0&1\\
	\end{bmatrix}
	&=
	\begin{bmatrix}
	0&1\\
	1&1\\
	\end{bmatrix}
	\end{align*}
\end{definition}

\subsection{Stability}

Stability can be computed by checking whether $E$ exists within a all possible stable extensions of some $\langle Args, \rightsquigarrow\rangle$. However, a schedule cannot be reasoned on without understanding whether $E$ may be stable on $\langle Args, \rightsquigarrow\rangle$. Existing solutions require a complication pipeline using answer set solvers. To make the implementation of the tool easier, we adapt the stability computation to schedules into a concise algorithm.

\begin{algorithm}
	\begin{algorithmic}[1]
		\Function{Explain-Stability}{$\mathbf{x}$, $\rightsquigarrow$,
			 ignoreUnattacked, ignoreConflicts}
			\State unattacked $\gets\incircbin{\neg}$ $\mathbf{x}$
			\State conflicts $\gets\mathbf{0}^{(m\times n)^2}$
			\For{$i\in\mathcal{M}$}
				\For{$j\in\mathcal{J}$}
					\If{$E_{i,j}=1$}
						\State unattacked $\gets$ unattacked $\incircbin{\land}$ $\incircbin{\neg}\rightsquigarrow_{i,j}$
						\State conflicts$_{i,j}$ $\gets$ $\mathbf{x}$ $\incircbin{\land}$ $\rightsquigarrow_{i,j}$ 
					\EndIf
				\EndFor
			\EndFor
			\State unattacked $\gets$ unattacked $\incircbin{\land}$ $\incircbin{\neg}$ ignoreUnattacked
			\State conflicts $\gets$ conflicts $\incircbin{\land}$ $\incircbin{\neg}$ ignoreConflicts
			\State \Return unattacked, conflicts
		\EndFunction
	\end{algorithmic}
\end{algorithm}

The function returns two tensors, \emph{unattacked} encode the unattacked nodes and \emph{conflicts} encode the edges are not conflict-free. \emph{ignoreUnattack} and \emph{ignoreConflicts} represent node and edges to ignore from returned values respectively, which are useful in tailoring explanations to particular constraints. By default, ignoreUnattacked $=\mathbf{0}$ and ignoreConflicts $=\mathbf{0}$. The algorithm has $\mathcal{O}(m^2n^2)$ computational and memory complexity. The function uses $\mathbf{x}$ rather than its equivalent representation $E$ because $\mathbf{x}$ can be manipulated directly from an optimiser in its tensor form unlike $E$. In addition, it is assumed that $E\subseteq Args$ so $Args$ does not need to be a parameter.

\begin{theorem}
	\textsc{Explain-Stability} is correct where $\mathbf{x}\approx E$ under $S$:
	\begin{align*}
		\textsc{Explain-Stability}(\mathbf{x},\rightsquigarrow,\mathbf{0},\mathbf{0})=\langle \mathbf{0},\mathbf{0}\rangle\Leftrightarrow E\text{ is stable on }\langle Args, \rightsquigarrow\rangle
	\end{align*}
\end{theorem}
	
\subsection{Explanation}

\begin{algorithm}
	\begin{algorithmic}[1]
		\Function{Explain-Schedule}{$m$, $n$, $\mathbf{p}$, $D$, $\mathbf{x}$}
				\State $\rightsquigarrow_F$ $\gets$ \textsc{Construct-Feasibility}($m$, $n$)
				\State $\langle$ unattacked\textsubscript{F}, conflicts\textsubscript{F} $\rangle$ $\gets$ \textsc{Explain-Stability}($\mathbf{x}$, $\rightsquigarrow_F$, $\mathbf{0}$, $\mathbf{0}$)
				\State explanation\textsubscript{F} $\gets$ \textsc{Explain-Feasibility}(unattacked\textsubscript{F}, conflicts\textsubscript{F})

				\State $\rightsquigarrow_S$ $\gets$ \textsc{Construct-Efficiency}($m$, $n$, $\mathbf{p}$, $\mathbf{x}$, $\rightsquigarrow_F$)
				\State $\langle$ unattacked\textsubscript{S}, conflicts\textsubscript{S} $\rangle$ $\gets$ \textsc{Explain-Stability}($\mathbf{x}$, $\rightsquigarrow_S$, unattacked\textsubscript{F}, conflicts\textsubscript{F})
				\State explanation\textsubscript{S} $\gets$ \textsc{Explain-Feasibility}(unattacked\textsubscript{F}, conflicts\textsubscript{S})

				\State $\rightsquigarrow_D$ $\gets$ \textsc{Construct-Satisfaction}($m$, $n$, $\mathbf{x}$, $\rightsquigarrow_F$)
				\State $\langle$ unattacked\textsubscript{D}, conflicts\textsubscript{D} $\rangle$ $\gets$ \textsc{Explain-Stability}($\mathbf{x}$, $\rightsquigarrow_D$, unattacked\textsubscript{F}, conflicts\textsubscript{F})
				\State explanation\textsubscript{D} $\gets$ \textsc{Explain-Feasibility}(unattacked\textsubscript{F}, conflicts\textsubscript{D})
				
				\State explanation $\gets$ \textsc{Aggregate}(explanation\textsubscript{F}, explanation\textsubscript{S}, explanation\textsubscript{D})
				\State \Return explanation
		\EndFunction
	\end{algorithmic}
\end{algorithm}
